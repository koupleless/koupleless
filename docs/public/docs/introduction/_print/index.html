<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.119.0"><link rel=canonical type=text/html href=/docs/introduction/><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>产品介绍 | Koupleless</title><meta name=description content><meta property="og:title" content="产品介绍"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/docs/introduction/"><meta itemprop=name content="产品介绍"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="产品介绍"><meta name=twitter:description content><link rel=preload href=/scss/main.min.dd7b72f9267db0e97a69cb30707c5fc5882975a4ea1f005b8e16e8f65c5ea9b1.css as=style><link href=/scss/main.min.dd7b72f9267db0e97a69cb30707c5fc5882975a4ea1f005b8e16e8f65c5ea9b1.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<link rel=stylesheet href=/css/prism.css><meta name=google-site-verification content="iznGJXncH7YgD6J5kSrqbWh9GoPi5Zfzu1qJ9iDuID8"><link href=/img/logo.svg rel=icon type=image/svg><link href=/search/pagefind-ui.css rel=stylesheet><script src=/search/pagefind-ui.js type=text/javascript></script>
<script>window.addEventListener("DOMContentLoaded",e=>{new PagefindUI({element:".td-search"})})</script><script src=https://o.alicdn.com/mecloud/shell/dialog.js></script>
<script>window.AlimeDialog({from:"i1OVpVbH98"})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-DZ8Q3F0GZ7","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DZ8Q3F0GZ7"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DZ8Q3F0GZ7")}</script></head><body class=td-section><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="26" height="29" viewBox="0 0 26 29" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><linearGradient x1="52.6662558%" y1="95.7312514%" x2="35.7492678%" y2="11.0078657%" id="linearGradient-wxw43fh1xd-1"><stop stop-color="#9822e4" offset="0"/><stop stop-color="#e643fa" offset="86.0585504%"/><stop stop-color="#f876ff" offset="100%"/></linearGradient><path d="M15.9275871 1.54432572 15.936122 1.5594269 15.9445709 1.57457632 5.01248933 7.79418913 7.699 9.304l8.8412359-4.72420311.8668497-.49490764C17.4171462 4.0791454 17.4272394 4.07345885 17.4373647 4.06782987c1.474137-.81952243 3.3335154-.28885241 4.1530379 1.18528466L10.875 11.088l2.864 1.609 8.843271-5.6213813c1.1038914-.6292563 2.5021428-.23250173 3.1230817.88617614C25.8984381 8.30965565 25.9998668 8.70204694 25.9998668 9.10116416V19.9436637c0 1.3476373-1.002317 2.484932-2.3392704 2.6542897L22.9421516 22.6889619V10.4257286L20.457252 12.0257475 20.457758 23.6880152c0 1.2665471-1.0267393 2.2932864-2.2932864 2.2932864H17.59115L17.590252 13.8727475 15.106 15.473 15.1067564 27.0588825c0 1.0695936-.855616100000001 1.9366704-1.911072 1.9366704C12.8696714 28.9955529 12.5490782 28.9110348 12.2643947 28.7500365L1.63270516 23.3171586C.159863707 22.5645249-.423980046 20.7604209.328653641 19.2875794L.372104915 19.2057013 12.0490412 25.0797183 12.049 22.086 1.98952173 16.7675786C.51279311 15.9867912-.0513787599 14.1567129.729408593 12.6799843L.744416289 12.6519572.759717752 12.6240895 12.049 18.593 12.0490412 15.2566254 1.7391964 9.45898637C1.44132502 9.2850324 1.19527431 9.0328708 1.02697438 8.72907568c-.516688418-.93266477-.189466545-2.11320819.7308705-2.63681754C6.19445786 3.56812633 9.52191759 1.67502747 11.7402241.412961569L11.7628911.400065593c1.4660277-.834070345 3.3306257-.321767634 4.164696 1.144260127z" id="path-wxw43fh1xd-2"/><linearGradient x1="50.6099966%" y1="31.6743333%" x2="50.2419846%" y2="73.0702907%" id="linearGradient-wxw43fh1xd-4"><stop stop-color="#8200b5" offset="0"/><stop stop-color="#8200b5" stop-opacity="0" offset="100%"/></linearGradient><linearGradient x1="50.6028666%" y1="31.6743333%" x2="50.2391561%" y2="73.0702907%" id="linearGradient-wxw43fh1xd-5"><stop stop-color="#8200b5" offset="0"/><stop stop-color="#8200b5" stop-opacity="0" offset="100%"/></linearGradient><linearGradient x1="90.8235257%" y1="50%" x2="3.24041867%" y2="52.9415572%" id="linearGradient-wxw43fh1xd-6"><stop stop-color="#dd3ff7" stop-opacity="0" offset="0"/><stop stop-color="#ca23e4" offset="100%"/></linearGradient><linearGradient x1="74.3272776%" y1="35.8586031%" x2="19.6895996%" y2="19.3309621%" id="linearGradient-wxw43fh1xd-7"><stop stop-color="#b800d1" stop-opacity="0" offset="0"/><stop stop-color="#ae00c5" offset="100%"/></linearGradient><linearGradient x1="97.0070676%" y1="71.8003287%" x2="11.3661868%" y2="30.5044309%" id="linearGradient-wxw43fh1xd-8"><stop stop-color="#940ec7" offset="0"/><stop stop-color="#c435f0" stop-opacity="0" offset="100%"/></linearGradient></defs><g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="首页" transform="translate(-24.000000, -18.000000)"><g id="编组-4" transform="translate(24.000133, 16.000000)"><g id="路径-6-copy-2" transform="translate(0.000000, 2.004447)"><mask id="mask-wxw43fh1xd-3" fill="#fff"><use xlink:href="#path-wxw43fh1xd-2"/></mask><use id="Mask" fill="url(#linearGradient-wxw43fh1xd-1)" fill-rule="nonzero" xlink:href="#path-wxw43fh1xd-2"/><path d="M12.0490412 15.2684078 13.03943 15.5167092C14.3279076 16.0478608 15.1686754 17.3038563 15.1686754 18.6975193V18.7421449v9.047164l-3.1196342-1.4070083V15.2684078z" id="Path-114-Copy-2" fill="url(#linearGradient-wxw43fh1xd-4)" opacity=".69047619" mask="url(#mask-wxw43fh1xd-3)"/><path d="M22.9421516 10.4227424 23.8594661 10.2542707C24.8889759 10.219744 25.7876765 10.946368 25.9694916 11.9602841L26.0763097 12.5559692 26.0617858 22.9064645l-3.1196342-1.4070082V10.4227424z" id="Path-114-Copy-2" fill="url(#linearGradient-wxw43fh1xd-5)" opacity=".69047619" mask="url(#mask-wxw43fh1xd-3)"/><polygon id="Path-41" fill="url(#linearGradient-wxw43fh1xd-6)" mask="url(#mask-wxw43fh1xd-3)" points="7.6326499 9.31647968 11.9297751 6.77228295 14.9765833 9.31647968 10.7681311 11.1500753"/><path d="M6.16852974 12.7326226C8.05429918 13.6181711 7.86496926 14.83948 8.18831704 15.006813 8.70089861 15.2720748 9.14143095 17.098905 9.86115602 17.1695013 10.6949216 17.2512836 11.6478081 10.8552079 10.3936906 10.4556578 9.48069361 10.1647855 7.32719679 9.49121213 3.93320016 8.43493769c-.63204609 1.86851711.11306377 3.30107871 2.23532958 4.29768491z" fill="url(#linearGradient-wxw43fh1xd-7)" mask="url(#mask-wxw43fh1xd-3)" transform="translate(7.357416, 12.802608) rotate(-347.000000) translate(-7.357416, -12.802608)"/><polygon id="Path-43" fill="url(#linearGradient-wxw43fh1xd-8)" mask="url(#mask-wxw43fh1xd-3)" points="12.0699788 18.5615749 6.27140769 15.1359473 5.30588708 19.0963147 12.0699788 22.1120507"/></g></g></g></g></svg></span><span class=navbar-brand__name>Koupleless</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/home/><span>首页</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>产品文档</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>最新信息</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>参与社区</span></a></li><li class=nav-item><a class=nav-link href=/user-cases/><span>用户案例</span></a></li><li class="nav-item dropdown d-none d-lg-block"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>中文</a><ul class=dropdown-menu><li><a class=dropdown-item href=/no/></a></li></ul></div></li></ul></div><div class="d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder=站内搜索… aria-label=站内搜索… autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/docs/introduction/>返回本页常规视图</a>.</p></div><h1 class=title>产品介绍</h1><ul><li>1: <a href=#pg-fd977b0af51d1a489a61551eb5e32610>简介与适用场景</a></li><li>2: <a href=#pg-3a89b12892834b585df4690bf050d9d5>行业背景</a></li><li>3: <a href=#pg-1a655298f9f51d3790e457c666fd9032>架构介绍</a></li><ul><li>3.1: <a href=#pg-eae697a827c518b3c38ed9ee18d3ff71>架构原理</a></li><li>3.2: <a href=#pg-f3857e8be17ade9a35d641cc483d619b>基座与模块间类委托加载原理介绍</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-fd977b0af51d1a489a61551eb5e32610>1 - 简介与适用场景</h1><div class=lead>Koupleless 简介与适用场景</div><h1 id=简介>简介</h1><p>Koupleless 是一种模块化的 Serverless 技术解决方案，它能让普通应用以比较低的代价演进为 Serverless 研发模式，让代码与资源解耦，轻松独立维护，与此同时支持秒级构建部署、合并部署、动态伸缩等能力为用户提供极致的研发运维体验，最终帮助企业实现降本增效。<br>随着各行各业的信息化数字化转型，企业面临越来越多的研发效率、协作效率、资源成本和服务治理痛点，接下来带领大家逐一体验这些痛点，以及它们在 Koupleless 中是如何被解决的。</p><h1 id=适用场景>适用场景</h1><h2 id=痛点-1应用构建发布慢或者-sdk-升级繁琐>痛点 1：应用构建发布慢或者 SDK 升级繁琐</h2><p>传统应用镜像化构建一般要 3 - 5 分钟，单机代码发布到启动完成也要 3 - 5 分钟，开发者每次验证代码修改或上线代码修改，都需要经历<strong>数次 6 - 10 分钟</strong>的构建发布等待，严重影响开发效率。此外，每次 SDK 升级（比如中间件框架、rpc、logging、json 等），都需要修改所有应用代码并重新构建发布，对开发者也造成了不必要的打扰。<br>通过使用 <strong>Koupleless</strong> <strong>通用基座</strong>与配套工具，您可以低成本的将应用切分为 “<strong>基座</strong>” 与 “<strong>模块</strong>”，其中基座沉淀了公司或者某个业务部门的公共 SDK，基座升级可以由专人负责，对业务开发者无感，业务开发者只需要编写模块。在我们目前支持的 Java 技术栈中，模块就是一个 SpringBoot 应用代码包（FatJar），只不过 SpringBoot 框架本身和其他的企业公共依赖在运行时会让基座提前加载预热，模块每次发布都会找一台预热 SpringBoot 的基座进行热部署，整个过程类似 AppEngine，能够帮用户实现应用 <strong>10 秒级构建发布</strong>和<strong>公共 SDK 升级无感</strong>。</p><img width=800px alt=应用构建发布速度 src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/671/1694592240984-8ea49823-ebd0-4bb7-909c-380f0439382b.png#clientId=u0d56718b-4144-4&from=paste&height=164&id=uab4fd245&originHeight=328&originWidth=2350&originalType=binary&ratio=2&rotation=0&showTitle=false&size=259703&status=done&style=none&taskId=u4aa5d723-f988-41e6-86fc-8c08d59e517&title=&width=1175"><h2 id=痛点-2长尾应用资源成本高>痛点 2：长尾应用资源成本高</h2><p>在企业中，80% 的应用只服务了不到 20% 的流量，同时伴随着业务的变化，企业存在大量的<strong>长尾应用</strong>，这些长尾应用 CPU 使用率长期不到 10%，造成了极大的<strong>资源浪费</strong>。<br>通过使用 <strong>Koupleless</strong> <strong>合并部署</strong>与配套工具，您可以低成本的实现多个应用的合并部署，从而解决企业应用过度拆分和低流量业务带来的<strong>资源浪费</strong>，<strong>节约成本</strong>。<br><img width=700px alt=应用机器成本 src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/671/1694593117757-d2932c29-c4c2-4ecc-9a41-59a750d53823.png#clientId=u0d56718b-4144-4&from=paste&height=132&id=u349c574f&originHeight=318&originWidth=1382&originalType=binary&ratio=2&rotation=0&showTitle=false&size=158864&status=done&style=none&taskId=u1389af9d-06db-468f-810a-09bc615b751&title=&width=574"><br>这里 “业务A 应用1” 在 Koupleless 术语中叫 “模块”。多个模块应用可以使用 SOFAArk 技术合并到同一个基座。基座可以是完全空的 SpringBoot应用（Java 技术栈），也可以下沉一些公共 SDK 到基座，模块应用每次发布会重启基座机器。在这种方式下，模块应用最大程度复用了基座的<strong>内存</strong>（Metaspace 和 Heap），构建产物<strong>大小</strong>也能从<strong>数百 MB</strong> 瘦身到<strong>几十 MB</strong> 甚至更激进，<strong>CPU 使用率</strong>也得到了有效提升。</p><h2 id=痛点-3企业研发协作效率低>痛点 3：企业研发协作效率低</h2><p>在企业中，一些应用需要<strong>多人开发</strong>协作。在传统研发模式下，每一个人的代码变更都需要发布整个应用，这就导致应用需要以<strong>赶火车</strong>式的方式进行研发迭代，大家需要统一一个时间窗口做迭代开发，统一的时间点做发布上线，因此存在大量的需求上线相互<strong>等待</strong>、环境机器<strong>抢占</strong>、迭代<strong>冲突</strong>等情况。<br>通过使用 <strong>Koupleless</strong>，您可以方便的将应用拆分为一个<strong>基座</strong>与多个功能<strong>模块</strong>，一个功能模块就是一组代码文件。不同的功能模块可以<strong>同时进行</strong>迭代开发和发布运维，模块间<strong>互不感知互不影响</strong>，这样就消除了传统应用迭代赶火车式的相互等待，每个模块拥有自己的独立迭代，<strong>需求交付效率</strong>因此得到了极大提升。如果您对模块额外启用了<strong>热部署</strong>方式（也可以每次发布模块重启整个基座），那么模块的单次构建+发布也会从普通应用的 <strong>6 - 10 分钟减少到十秒级。</strong><br><img width=800px alt=协作效率低 src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/671/1694594675815-3037ffe1-2048-4c86-bc50-456697b197d5.png#clientId=u0d56718b-4144-4&from=paste&height=552&id=u36ac4b83&originHeight=1066&originWidth=1154&originalType=binary&ratio=2&rotation=0&showTitle=false&size=428189&status=done&style=none&taskId=u7fc53ae9-ff48-4ae5-a821-44dbee64aaa&title=&width=598"></p><h2 id=痛点-4难以沉淀业务资产提高中台效率>痛点 4：难以沉淀业务资产提高中台效率</h2><p>在一些中大型企业中，会沉淀各种<strong>业务中台</strong>应用。中台一般封装了业务的公共 API 实现，和 <strong>SPI</strong> 定义。其中 SPI 定义允许中台上的插件去实现各自的业务逻辑，流量进入中台应用后，会调用对应的 SPI 实现组件去完成相应的业务逻辑。中台应用内的组件，业务逻辑一般不复杂，如果拆出去部署为独立应用会带来高昂的<strong>资源成本和运维成本</strong>，而且构建发布<strong>速度很慢</strong>，严重加剧研发负担影响研发效率。<br>通过使用 Koupleless，您可以方便的将中台应用拆分一个<strong>基座</strong>和多个功能<strong>模块</strong>。基座可以沉淀比较厚的业务依赖、公共逻辑、API 实现、SPI 定义等（即所谓的业务资产），提供给上面的模块使用。模块使用基座的能力可以是对象之间或 Bean 之间的<strong>直接调用</strong>，代码几乎不用改造。而且多个模块间可以<strong>同时进行</strong>迭代开发和发布运维，<strong>互不感知互不影响</strong>，<strong>协作交付效率</strong>得到了极大提升。此外对于比较简单的模块还可以开启热部署，单次构建+发布也会从普通应用的 <strong>6 - 10 分钟减少到 30 秒内。</strong><br><img width=800px alt=提高中台效率 src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/671/1694601773808-b25f5beb-a4e4-4d93-ba55-6f61bf0377bc.png#clientId=u2162a7aa-3111-4&from=paste&height=386&id=uf98e4ae9&originHeight=1016&originWidth=1400&originalType=binary&ratio=2&rotation=0&showTitle=false&size=470581&status=done&style=none&taskId=u44970d8c-1234-447f-bbb6-ceea4a44cfc&title=&width=532"></p><h2 id=痛点-5微服务演进成本高>痛点 5：微服务演进成本高</h2><p>企业里不同业务有不同的发展阶段，因此应用也拥有自己的生命周期。</p><p><strong>初创期</strong>：一个初创的应用一般会先采用<strong>单体架构</strong>。<br>↓<br><strong>增长期</strong>：随着业务增长，应用开发者也随之增加。此时您可能<strong>不确定</strong>业务的未来前景，也不希望过早把业务拆分成多个应用以避免不必要的<strong>维护、治理和资源成本</strong>，那么您可以用 <strong>Koupleless</strong> 低成本地将应用<strong>拆分</strong>为一个基座和多个功能<strong>模块</strong>，不同功能模块之间可以并行研发运维独立迭代，从而提高应用在此阶段的研发协作和<strong>需求交付</strong>效率。<br>↓<br><strong>成熟期</strong>：随着业务进一步增长，您可以使用 Koupleless 低成本地将部分或全部功能模块<strong>拆分成独立应用</strong>去研发运维。<br>↓<br><strong>长尾期</strong>：部分业务在经历增长期或者成熟期后，也可能慢慢步入到低活状态或者长尾状态，此时您可以用 Koupleless 低成本地将这些应用<strong>一键改回模块</strong>，<strong>合并部署</strong>到一起实现<strong>降本增效</strong>。</p><p>可以看到 <strong>Koupleless</strong> 支持企业应用低成本地在初创期、增长期、成熟期、长尾期之间平滑过渡甚至来回切换，从而轻松让应用架构与业务发展保持同步。<br>应用生命周期演进<br><img width=1200px alt=微服务演进成本 src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/671/1694602307402-510d44ec-314c-44c4-96d8-bb978dd027ff.png#clientId=u2162a7aa-3111-4&from=paste&height=217&id=u8b5b547c&originHeight=434&originWidth=2458&originalType=binary&ratio=2&rotation=0&showTitle=false&size=266126&status=done&style=none&taskId=u09776530-0a41-4081-be17-c42db50e8b1&title=&width=1229"></p><br><br></div><div class=td-content style=page-break-before:always><h1 id=pg-3a89b12892834b585df4690bf050d9d5>2 - 行业背景</h1><div class=lead>Koupleless 背景</div><h2 id=微服务的问题>微服务的问题</h2><p>应用架构从单体应用发展到微服务，结合软件工程从瀑布模式到当前的 DevOps 模式的发展，解决了可扩展、分布式、分工协作等问题，为企业提供较好的敏捷性与执行效率，带来了明显的价值。但该模式发展至今，虽然解决了一些问题，也有微服务的一些问题慢慢暴露出来，在当前已经得到持续关注：</p><h3 id=基础设施复杂>基础设施复杂</h3><h4 id=认知负载高>认知负载高</h4><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695086284703-13a90661-9735-4daa-a7ec-dfc3a28ca2bd.png#clientId=ue95e757a-3cd6-4&amp;from=paste&amp;height=260&amp;id=ubf4cf860&amp;originHeight=942&amp;originWidth=1738&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=404365&amp;status=done&amp;style=none&amp;taskId=udcdc41a4-9949-4f53-98ca-e722e63bfc8&amp;title=&amp;width=479" alt=image.png><br>当前业务要完成一个需求，背后实际上有非常多的依赖、组件和平台在提供各种各样的能力，只要这些业务以下的某一个组件出现异常被业务感知到，都会对业务研发人员带来较大认知负担和对应恢复的时间成本。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695086591548-8ac5f4b6-b5e2-4ba4-aa1e-35ff6816634a.png#clientId=ue95e757a-3cd6-4&amp;from=paste&amp;height=200&amp;id=ub7a3e5b4&amp;originHeight=596&amp;originWidth=582&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=415294&amp;status=done&amp;style=none&amp;taskId=u6e187ff5-dade-4172-83e4-38a90d4ad38&amp;title=&amp;width=195" alt=image.png><br>异常种类繁多</p><h4 id=运维负担重>运维负担重</h4><p>业务包含的各个依赖也会不断迭代升级，例如框架、中间件、各种 sdk 等，在遇到</p><ol><li>重要功能版本发布</li><li>修复紧急 bug</li><li>遇到重大安全漏洞</li></ol><p>等情况时，这些依赖的新版本就需要业务尽可能快的完成升级，这造成了两方面的问题：</p><h5 id=对于业务研发人员>对于业务研发人员</h5><p>这些依赖的升级如果只是一次两次那么就不算是问题，但是一个业务应用背后依赖的框架、中间件与各类 sdk 是很多的，每一个依赖发布这些升级都需要业务同学来操作，这么多个依赖的话长期上就会对业务研发同学来说是不小的运维负担。另外这里也需要注意到业务公共层对业务开发者来说也是不小的负担。</p><h5 id=对于基础设施人员>对于基础设施人员</h5><p>类似的对于各个依赖的开发人员自身，每发布一个这样的新版本，需要尽可能快的让使用的业务应用完成升级。但是业务研发人员更关注业务需求交付，想要推动业务研发人员快速完成升级是不太现实的，特别是在研发人员较多的企业里。</p><h4 id=启动慢>启动慢</h4><p>每个业务应用启动过程都需要涉及较多过程，造成一个功能验证需要花费较长等待时间。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695088271232-52d649a0-0e21-46b3-aaf4-43d0d908d279.png#clientId=ue95e757a-3cd6-4&amp;from=paste&amp;height=83&amp;id=uf009ae3a&amp;originHeight=180&amp;originWidth=1234&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=52685&amp;status=done&amp;style=none&amp;taskId=u56e65597-48ba-47f8-b8b6-c69a8ceebf3&amp;title=&amp;width=570" alt=image.png></p><h4 id=发布效率低>发布效率低</h4><p>由于上面提到的启动慢、异常多的问题，在发布上线过程中需要较长时间，出现异常导致卡单需要恢复处理。发布过程中除了平台异常外，机器异常发生的概率会随着机器数量的增多而增多，假如一台机器正常完成发布（不发生异常）的概率是 99.9%，也就是一次性成功率为 99.9%，那么100台则是 90%，1000台则降低到了只有 36.7%，所以对于机器较多的应用发布上线会经常遇到卡单的问题，这些都需要研发人员介入处理，导致效率低。</p><h3 id=协作与资源成本高>协作与资源成本高</h3><h4 id=单体应用大应用过大>单体应用/大应用过大</h4><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695109775918-de436da0-8187-45a8-a30a-62177a55181e.png#clientId=u02591eed-2e18-4&amp;from=paste&amp;height=106&amp;id=u28baf164&amp;originHeight=304&amp;originWidth=1412&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=97660&amp;status=done&amp;style=none&amp;taskId=u468dfc48-8b76-484e-abb6-36aed56dfd8&amp;title=&amp;width=494" alt=image.png></p><h5 id=多人协作阻塞>多人协作阻塞</h5><p>业务不断发展，应用会不断变大，这主要体现在开发人员不断增多，出现多人协作阻塞问题。</p><h5 id=变更影响面大风险高>变更影响面大，风险高</h5><p>业务不断发展，线上流量不断增大，机器数量也不断增多，但当前一个变更可能影响全部代码和机器流量，变更影响面大风险高。</p><h4 id=小应用过多>小应用过多</h4><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695111071288-b27e64a3-ff6f-4457-9353-5a4b337faccf.png#clientId=u02591eed-2e18-4&amp;from=paste&amp;height=110&amp;id=ua230cdfe&amp;originHeight=302&amp;originWidth=1404&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=76471&amp;status=done&amp;style=none&amp;taskId=ua211c1f6-fe53-43fa-8be8-7da9a92e8cb&amp;title=&amp;width=512" alt=image.png><br>在微服务发展过程中，随着时间的推移，例如部分应用拆分过多、某些业务萎缩、组织架构调整等，都会出现线上小应用或者长尾应用不断积累，数量越来越多，像蚂蚁过去3年应用数量增长了 3倍。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695111122234-8a85eee7-bdf5-40c6-85e2-5955413f9c7d.png#clientId=u02591eed-2e18-4&amp;from=paste&amp;height=177&amp;id=uf7c75dd0&amp;originHeight=1182&amp;originWidth=1538&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=140920&amp;status=done&amp;style=none&amp;taskId=uaadf29d5-7052-4316-9073-5ce5a4f92d4&amp;title=&amp;width=230" alt=image.png></p><h5 id=资源成本高>资源成本高</h5><p>这些应用每个机房都需要几台机器，但其实流量也不大，cpu 使用率很低，造成资源浪费。</p><h5 id=长期维护成本>长期维护成本</h5><p>这些应用同样需要人员来维度，例如升级 SDK，修复安全漏洞等，长期维护成本高。</p><h4 id=问题必然性>问题必然性</h4><p>微服务系统是个生态，在一个公司内发展演进几年后，参考28定律，少数的大应用占有大量的流量，不可避免的会出现大应用过大和小应用过多的问题。<br>然而大应用多大算大，小应用多少算多，这没有定义的标准，所以这类问题造成的研发人员的痛点是隐匿的，没有痛到一定程度是较难引起公司管理层面的关注和行动。</p><h3 id=如何合理拆分微服务>如何合理拆分微服务</h3><p>微服务如何合理拆分始终是个老大难的问题，合理拆分始终没有清晰的标准，这也是为何会存在上述的大应用过大、小应用过多问题的原因。而这些问题背后的根因是业务与组织灵活，与微服务拆分的成本高，两者的敏捷度不一致。</p><h4 id=微服务的拆分与业务和组织发展敏捷度不一致>微服务的拆分与业务和组织发展敏捷度不一致</h4><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695113016136-8d591312-1300-496e-9df8-a5ed1a49abe4.png#clientId=u02591eed-2e18-4&amp;from=paste&amp;height=201&amp;id=u7ce79cce&amp;originHeight=554&amp;originWidth=1222&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=182342&amp;status=done&amp;style=none&amp;taskId=uf3c867d4-2d82-4922-a6d9-6572ca3a1f7&amp;title=&amp;width=443" alt=image.png><br>业务发展灵活，组织架构也在不断调整，而微服务拆分需要机器与长期维护的成本，两者的敏捷度不一致，导致容易出现未拆或过度拆分问题，从而出现大应用过大和小应用过多问题。这类问题不从根本上解决，会导致微服务应用治理过一波之后还会再次出现问题，导致研发同学始终处于低效的痛苦与治理的痛苦循环中。</p><h3 id=不同体量企业面对的问题>不同体量企业面对的问题</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695131026232-1e25044b-d0d4-4a58-9d03-ef665365fbc6.png#clientId=ucec7e736-7c4f-4&amp;from=paste&amp;height=511&amp;id=uc85ea670&amp;originHeight=1022&amp;originWidth=3766&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=244352&amp;status=done&amp;style=none&amp;taskId=u18416169-fc43-47a4-8486-9e5e328552c&amp;title=&amp;width=1883" alt=image.png></p><h3 id=行业尝试的解法>行业尝试的解法</h3><p>当前行业里也有很多不错的思路和项目在尝试解决这些问题，例如服务网格、应用运行时、平台工程，Spring Modulith、Google ServiceWeaver，有一定的效果，但也存在一定的局限性：</p><ol><li>从业务研发人员角度看，只屏蔽部分基础设施，未屏蔽业务公共部分</li><li>只解决其中部分问题</li><li>存量应用接入改造成本高</li></ol><p>Koupleless 的目的是为了解决这些问题而不断演进出来的一套研发框架与平台能力。</p><br><br></div><div class=td-content style=page-break-before:always><h1 id=pg-1a655298f9f51d3790e457c666fd9032>3 - 架构介绍</h1></div><div class=td-content><h1 id=pg-eae697a827c518b3c38ed9ee18d3ff71>3.1 - 架构原理</h1><div class=lead>Koupleless 架构</div><h2 id=模块化应用架构>模块化应用架构</h2><p>为了解决这些问题，我们对应用同时做了横向和纵向的拆分。首先第一步纵向拆分：把应用拆分成<strong>基座</strong>和<strong>业务</strong>两层，这两层分别对应两层的组织分工。基座小组与传统应用一样，负责机器维护、通用逻辑沉淀、业务架构治理，并为业务提供运行资源和环境。通过关注点分离的方式为业务屏蔽业务以下所有基础设施，聚焦在业务自身上。第二部我们将业务进行横向切分出多个模块，多个模块之间独立并行迭代互不影响，同时模块由于不包含基座部分，构建产物非常轻量，启动逻辑也只包含业务本身，所以启动快，具备秒级的验证能力，让模块开发得到极致的提效。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695131313965-18385213-eded-4a6b-b554-db5312fa2c9d.png#clientId=ua84a92a5-30aa-4&amp;from=paste&amp;height=431&amp;id=udb6b29d5&amp;originHeight=862&amp;originWidth=3448&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=192627&amp;status=done&amp;style=none&amp;taskId=u9a114a24-0887-48d9-87b2-57d3e15eb80&amp;title=&amp;width=1724" alt=image.png><br>拆分之前，每个开发者可能感知从框架到中间件到业务公共部分到业务自身所有代码和逻辑，拆分后，团队的协作分工也从发生改变，研发人员分工出两种角色，基座和模块开发者，模块开发者不关系资源与容量，享受秒级部署验证能力，聚焦在业务逻辑自身上。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695131554610-ef5c4a2f-0080-45eb-8fed-55fdf5d827f9.png#clientId=ua84a92a5-30aa-4&amp;from=paste&amp;height=459&amp;id=u7227f759&amp;originHeight=918&amp;originWidth=3714&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=309179&amp;status=done&amp;style=none&amp;taskId=u12307968-2a79-4f77-9c78-e976399c60e&amp;title=&amp;width=1857" alt=image.png></p><p>这里要重点看下我们是如何做这些纵向和横向切分的，切分是为了隔离，隔离是为了能够独立迭代、剥离不必要的依赖，然而如果只是隔离是没有共享相当于只是换了个部署的位置而已，很难有好的效果。所以我们除了隔离还有共享能力，所以这里需要聚焦在隔离与共享上来理解模块化架构背后的原理。</p><h3 id=模块的定义>模块的定义</h3><p>在这之前先看下这里的模块是什么？模块是通过原来应用减去基座部分得到的，这里的减法是通过设置模块里依赖的 scope 为 provided 实现的，<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695132446404-0571be28-5cdf-452e-90f5-001a4209c750.png#clientId=u177778f7-e9cd-4&amp;from=paste&amp;height=142&amp;id=ud796498d&amp;originHeight=516&amp;originWidth=1834&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=108247&amp;status=done&amp;style=none&amp;taskId=u8201db6e-cf5e-4fbd-ab24-6a0223e1709&amp;title=&amp;width=506" alt=image.png><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695132481921-6fb1c3da-0de3-46ce-bf8e-cc645f63157c.png#clientId=u177778f7-e9cd-4&amp;from=paste&amp;height=187&amp;id=u31cba15e&amp;originHeight=524&amp;originWidth=1026&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=205261&amp;status=done&amp;style=none&amp;taskId=u2c981d7a-dfff-43c6-b6c6-5c6a5701d2b&amp;title=&amp;width=367" alt=image.png><br>一个模块可以由这三点定义：</p><ol><li>SpringBoot 打包生成的 jar 包</li><li>一个模块： 一个 SpringContext + 一个 ClassLoader</li><li>热部署（升级的时候不需要启动进程）</li></ol><h3 id=模块的隔离与共享>模块的隔离与共享</h3><p>模块通过 ClassLoader 隔离配置和代码，SpringContext 隔离 Bean 和服务，可以通过调用 Spring ApplicationContext 的start close 方法来动态启动和关闭服务。通过 SOFAArk 来共享模块和基座的配置和代码 Class，通过 SpringContext Manager 来共享多模块间的 Bean 和服务。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695132610081-3efe470f-5c65-4d46-b4e4-1ecb15c8d789.png#clientId=u771aab18-101c-4&amp;from=paste&amp;height=313&amp;id=u4c63a679&amp;originHeight=972&amp;originWidth=1334&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=160772&amp;status=done&amp;style=none&amp;taskId=uafe9a1eb-025c-4e1e-9316-35b8bd32b96&amp;title=&amp;width=429" alt=image.png><br>并且在 JVM 内通过</p><ol><li>Ark Container 提供多 ClassLoader 运行环境</li><li>Arklet 来管理模块生命周期</li><li>Framework Adapter 将 SpringBoot 生命周期与模块生命周期关联起来</li><li>SOFAArk 默认委托加载机制，打通模块与基座类委托加载</li><li>SpringContext Manager 提供 Bean 与服务发现调用机制</li><li>基座本质也是模块，拥有独立的 SpringContext 和 ClassLoader</li></ol><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695139080634-1669ea76-c486-47fc-ac4f-5900833896b9.png#clientId=u71a0730f-fb54-4&amp;from=paste&amp;height=275&amp;id=u1cf30803&amp;originHeight=722&amp;originWidth=1428&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=198221&amp;status=done&amp;style=none&amp;taskId=u88cd7c27-4850-4b02-9c6f-504b4456a94&amp;title=&amp;width=544" alt=image.png></p><p>但是在 Java 领域模块化技术已经发展了20年了，为什么这里的模块化技术能够在蚂蚁内部规模化落地，这里的核心原因是<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695139240123-37a5b5e7-38ee-4b33-b84b-4d58e8b9f371.png#clientId=u71a0730f-fb54-4&amp;from=paste&amp;height=596&amp;id=u7b5e0183&amp;originHeight=1192&amp;originWidth=2954&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=587199&amp;status=done&amp;style=none&amp;taskId=uc2ceea08-092e-4bfd-9566-d97ab3d3b74&amp;title=&amp;width=1477" alt=image.png><br>基于 SOFAArk 和 SpringContext Manager 的多模块能力，提供了低成本的使用方式。</p><h4 id=隔离方面>隔离方面</h4><p>对于其他的模块化技术，从隔离角度来看，JPMS 和 Spring Modulith 的隔离是通过自定义的规则来做限制的，Spring Modulith 还需要在单元测试里执行 verify 来做校验，隔离能力比较弱且一定程度上是比较 tricky 的，对于存量应用使用来说也是有不小改造成本的，甚至说是存量应用无法改造。而 SOFAArk 和 OSGI 一样采用 ClassLoader 和 SpringContext 的方式进行配置与代码、bean与服务的隔离，对原生应用的启动模式完全保持一致。</p><h4 id=共享方面>共享方面</h4><p>SOFAArk 的隔离方式和 OSGI 是一致的，但是在共享方面 OSGI 和 JPMS、Spring Modulith 一样都需要在源模块和目标模块间定义导入导出列表或其他配置，这造成业务使用模块需要强感知和理解多模块的技术，使用成本是比较高的，而 SOFAArk 则定义了默认的类委托加载机制，和跨模块的 Bean 和服务发现机制，让业务不用改造的情况下能够使用多模块的能力。<br>这里额外提下，为什么基于 SOFAArk 的多模块化技术能提供这些默认的能力，而做到低成本的使用呢？这里主要的原因是因为我们对模块做了角色的区分，区分出了基座与模块，在这个核心原因基础上也对低成本使用这块比较重视，做了重要的设计考量和取舍。具体有哪些设计和取舍，可以查看技术实现文章。</p><h3 id=模块间通信>模块间通信</h3><p>模块间通信主要依托 SpringContext Manager 的 Bean 与服务发现调用机制提供基础能力，<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695171905613-2546f555-ff25-4a58-81aa-02d77bfb2b1d.png#clientId=ud7a2066a-ba29-4&amp;from=paste&amp;height=307&amp;id=uc8826222&amp;originHeight=724&amp;originWidth=1048&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=202275&amp;status=done&amp;style=none&amp;taskId=u537670c5-c728-487a-9710-80986ce8532&amp;title=&amp;width=444" alt=image.png></p><h3 id=模块的可演进>模块的可演进</h3><p>回顾背景里提到的几大问题，可以看到通过模块化架构的隔离与共享能力，可以解决掉基础设施复杂、多人协作阻塞、资源与长期维护成本高的问题，但还有微服务拆分与业务敏捷度不一致的问题未解决。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695175219841-965cd163-a4bd-4cd0-b828-c620b29c0ffc.png#clientId=uaaa65411-0843-4&amp;from=paste&amp;height=185&amp;id=ua68375b7&amp;originHeight=894&amp;originWidth=2906&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=417377&amp;status=done&amp;style=none&amp;taskId=ud94c9602-7cd1-4bcb-8654-39fe8938d37&amp;title=&amp;width=602" alt=image.png><br>在这里我们通过降低微服务拆分的成本来解决，那么怎么降低微服务拆分成本呢？这里主要是在单体架构和微服务架构之间增加模块化架构</p><ol><li>模块不占资源所以拆分没有资源成本</li><li>模块不包含业务公共部分和框架、中间件部分，所以模块没有长期的 sdk 升级维护成本</li><li>模块自身也是 SpringBoot，我们提供工具辅助单体应用低成本拆分成模块应用</li><li>模块具备灵活部署能力，可以合并部署在一个 JVM 内，也可拆除独立部署，这样模块可以按需低成本演进成微服务或回退会单体应用模式</li></ol><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695175141130-d3b55e17-70c3-4e7c-aeef-2e071f89ada8.png#clientId=uaaa65411-0843-4&amp;from=paste&amp;height=316&amp;id=u589ef06e&amp;originHeight=632&amp;originWidth=3642&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=139102&amp;status=done&amp;style=none&amp;taskId=uf9f96d68-7456-4af5-951e-d9351092988&amp;title=&amp;width=1821" alt=image.png><br>图中的箭头是双向的，如果当前微服务拆分过多，也可以将多个微服务低成本改造成模块合并部署在一个 JVM 内。所以这里的本质是通过在单体架构和微服务架构之间增加一个可以双向过渡的模块化架构，降低改造成本的同时，也让开发者可以根据业务发展按需演进或回退。这样可以把微服务的这几个问题解决掉</p><h3 id=模块化架构的优势>模块化架构的优势</h3><p>模块化架构的优势主要集中在这四点：快、省、灵活部署、可演进，<br><img src=https://github.com/sofastack/sofa-serverless/assets/3754074/11d1d662-d33b-482b-946b-bf600aeb34da alt=image.png></p><p>与传统应用对比数据如下，可以看到在研发阶段、部署阶段、运行阶段都得到了10倍以上的提升效果。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695180250909-f5eca1b3-c416-4bac-9732-549a9bed8b87.png#clientId=ueb39d37f-ca7b-4&amp;from=paste&amp;height=261&amp;id=u8907b613&amp;originHeight=522&amp;originWidth=2838&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=219589&amp;status=done&amp;style=none&amp;taskId=ua4b2bd1b-a75f-4945-abce-68826a43377&amp;title=&amp;width=1419" alt=image.png></p><h2 id=平台架构>平台架构</h2><p>只有应用架构还不够，需要从研发阶段到运维阶段到运行阶段都提供完整的配套能力，才能让模块化应用架构的优势真正触达到研发人员。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695182073971-12b14861-b6fa-470c-a140-737d40ff0b3e.png#clientId=u9014394b-3a6a-4&amp;from=paste&amp;height=192&amp;id=ub53430b2&amp;originHeight=384&amp;originWidth=1720&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=79335&amp;status=done&amp;style=none&amp;taskId=u1eb2a897-c2ca-437f-8d56-7067be175e2&amp;title=&amp;width=860" alt=image.png><br>在研发阶段，需要提供基座接入能力，模块创建能力，更重要的是模块的本地快速构建与联调能力；在运维阶段，提供快速的模块发布能力，在模块发布基础上提供 A/B 测试和秒级扩缩容能力；在运行阶段，提供模块的可靠性能力，模块可观测、流量精细化控制、调度和伸缩能力。</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695182125970-f9529014-0386-4922-b8eb-5d0c82a7e5d8.png#clientId=u9014394b-3a6a-4&amp;from=paste&amp;height=370&amp;id=uf365ffd8&amp;originHeight=740&amp;originWidth=2096&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=242246&amp;status=done&amp;style=none&amp;taskId=uf07de18d-931e-4ffd-9540-d4be10de3e7&amp;title=&amp;width=1048" alt=image.png><br>组件视图</p><p>在整个平台里，需要四个组件：</p><ol><li>研发工具 Arkctl, 提供模块创建、快速联调测试等能力</li><li>运行组件 SOFAArk, Arklet，提供模块运维、模块生命周期管理，多模块运行环境</li><li>控制面组件 ModuleController<ol><li>ModuleDeployment 提供模块发布与运维能力</li><li>ModuleScheduler 提供模块调度能力</li><li>ModuleScaler 提供模块伸缩能力</li></ol></li></ol><br></div><div class=td-content style=page-break-before:always><h1 id=pg-f3857e8be17ade9a35d641cc483d619b>3.2 - 基座与模块间类委托加载原理介绍</h1><div class=lead>Koupleless 基座与模块间类委托加载原理介绍</div><h2 id=多模块间类委托加载>多模块间类委托加载</h2><p>SOFAArk 框架是基于多 ClassLoader 的通用类隔离方案，提供类隔离和应用的合并部署能力。本文档并不打算介绍 SOFAArk 类隔离的<a href=https://www.sofastack.tech/projects/sofa-boot/sofa-ark-classloader/>原理与机制</a>，这里主要介绍多 ClassLoader 当前的最佳实践。<br>当前基座与模块部署在 JVM 上的 ClassLoader 模型如图：<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/149473/1653304883689-ec30b72b-1620-4a2a-8611-d6c24107afd2.png#clientId=u8aaeb3a3-ec6f-4&amp;from=paste&amp;height=225&amp;id=u1df6aa1c&amp;originHeight=450&amp;originWidth=388&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39808&amp;status=done&amp;style=none&amp;taskId=uf6233ec3-9494-4b6a-b1b6-43546035a43&amp;title=&amp;width=194" alt=image.png></p><h2 id=当前类委托加载机制>当前类委托加载机制</h2><p>当前一个模块在启动与运行时查找的类，有两个来源：当前模块本身，基座。这两个来源的理想优先级顺序是，优先从模块中查找，如果模块找不到再从基座中查找，但当前存在一些特例：</p><ol><li>当前定义了一份白名单，白名单范围内的依赖会强制使用基座里的依赖。</li><li>模块可以扫描到基座里的所有类：<ul><li>优势：模块可以引入较少依赖</li><li>劣势：模块会扫描到模块代码里不存在的类，例如会扫描到一些 AutoConfiguration，初始化时由于第四点扫描不到对应资源，所以会报错。</li></ul></li><li>模块不能扫描到基座里的任何资源：<ul><li>优势：不会与基座重复初始化相同的 Bean</li><li>劣势：模块启动如果需要基座的资源，会因为查找不到资源而报错，除非模块里显示引入（Maven 依赖 scope 不设置成 provided）</li></ul></li><li>模块调用基座时，部分内部处理传入模块里的类名到基座，基座如果存在直接从基座 ClassLoader 查找模块传入的类，会查找不到。因为委托只允许模块委托给基座，从基座发起的类查找不会再次查找模块里的。</li></ol><h3 id=使用时需要注意事项>使用时需要注意事项</h3><p>模块要升级委托给基座的依赖时，需要让基座先升级，升级之后模块再升级。</p><h2 id=类委托的最佳实践>类委托的最佳实践</h2><p>类委托加载的准则是中间件相关的依赖需要放在同一个的 ClassLoader 里进行加载执行，达到这种方式的最佳实践有两种：</p><h3 id=强制委托加载>强制委托加载</h3><p>由于中间件相关的依赖一般需要在同一个 ClassLoader 里加载运行，所以我们会制定一个中间件依赖的白名单，强制这些依赖委托给基座加载。</p><h4 id=使用方法>使用方法</h4><p>application.properties 里增加配置 <code>sofa.ark.plugin.export.class.enable=true</code>。</p><h4 id=优点>优点</h4><p>模块开发者不需要感知哪些依赖属于需要强制加载由同一个 ClassLoader 加载的依赖。</p><h4 id=缺点>缺点</h4><p>白名单里要强制加载的依赖列表需要维护，列表的缺失需要更新基座，较为重要的升级需要推所有的基座升级。</p><h3 id=自定义委托加载>自定义委托加载</h3><p>模块里 pom 通过设置依赖的 scope 为 <code>provided</code>主动指定哪些要委托给基座加载。通过模块瘦身把与基座重复的依赖委托给基座加载，并在基座里预置中间件的依赖（可选，虽然模块暂时不会用到，但可以提前引入，以备后续模块需要引入的时候不需再发布基座即可引入）。这里：</p><ol><li>基座尽可能的沉淀通用的逻辑和依赖，特别是中间件相关以 <code>xxx-alipay-sofa-boot-starter </code>命名的依赖。</li><li>基座里预置一些公共依赖（可选）。</li><li>模块里的依赖如果基座里面已经有定义，则模块里的依赖尽可能的委托给基座，这样模块会更轻（提供自动模块瘦身的工具）。模块里有两种途径设置为委托给基座：<ol><li>依赖里的 scope 设置为 provided，注意通过 mvn dependency:tree 查看是否还有其他依赖设置成了 compile，需要所有的依赖引用的地方都设置为 provided。</li><li>biz 打包插件<code>sofa-ark-maven-plugin</code>里设置 <code>excludeGroupIds</code> 或 <code>excludeArtifactIds</code></li></ol></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>            <span style=color:#204a87;font-weight:700>&lt;plugin&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#204a87;font-weight:700>&lt;groupId&gt;</span>com.alipay.sofa<span style=color:#204a87;font-weight:700>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#204a87;font-weight:700>&lt;artifactId&gt;</span>sofa-ark-maven-plugin<span style=color:#204a87;font-weight:700>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#204a87;font-weight:700>&lt;configuration&gt;</span> 
</span></span><span style=display:flex><span>                    <span style=color:#204a87;font-weight:700>&lt;excludeGroupIds&gt;</span>io.netty,org.apache.commons,......<span style=color:#204a87;font-weight:700>&lt;/excludeGroupIds&gt;</span>
</span></span><span style=display:flex><span>                    <span style=color:#204a87;font-weight:700>&lt;excludeArtifactIds&gt;</span>validation-api,fastjson,hessian,slf4j-api,junit,velocity,......<span style=color:#204a87;font-weight:700>&lt;/excludeArtifactIds&gt;</span>
</span></span><span style=display:flex><span>                    <span style=color:#204a87;font-weight:700>&lt;declaredMode&gt;</span>true<span style=color:#204a87;font-weight:700>&lt;/declaredMode&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#204a87;font-weight:700>&lt;/configuration&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#204a87;font-weight:700>&lt;/plugin&gt;</span>
</span></span></code></pre></div><p>通过 2.a 的方法需要确保所有声明的地方 scope 都设置为provided，通过2.b的方法只要指定一次即可，建议使用方法 2.b。</p><ol start=4><li>只有模块声明过的依赖才可以委托给基座加载。</li></ol><p>模块启动的时候，Spring 框架会有一些扫描逻辑，这些扫描如果不做限制会查找到模块和基座的所有资源，导致一些模块明明不需要的功能尝试去初始化，从而报错。SOFAArk 2.0.3 之后新增了模块的 declaredMode, 来限制只有模块里声明过的依赖才可以委托给基座加载。只需在模块的打包插件的 Configurations 里增加 <code>&lt;declaredMode>true&lt;/declaredMode></code>即可。</p><h4 id=优点-1>优点</h4><p>不需要维护 plugin 的强制加载列表，当部分需要由同一 ClassLoader 加载的依赖没有设置为统一加载时，可以修改模块就可以修复，不需要发布基座（除非基座确实依赖）。</p><h4 id=缺点-1>缺点</h4><p>对模块瘦身的依赖较强。</p><h3 id=对比与总结>对比与总结</h3><table><thead><tr><th></th><th>依赖缺失排查成本</th><th>修复成本</th><th>模块改造成本</th><th>维护成本</th></tr></thead><tbody><tr><td>强制加载</td><td>类转换失败或类查找失败，成本中</td><td>更新 plugin，发布基座，高</td><td>低</td><td>高</td></tr><tr><td>自定义委托加载</td><td>类转换失败或类查找失败，成本中</td><td>更新模块依赖，如果基座依赖不足，需要更新基座并发布，中</td><td>高</td><td>低</td></tr><tr><td>自定义委托加载 + 基座预置依赖 + 模块瘦身</td><td>类转换失败或类查找失败，成本中</td><td>更新模块依赖，设置为 provided，低</td><td>低</td><td>低</td></tr></tbody></table><h4 id=结论推荐自定义委托加载方式>结论：推荐自定义委托加载方式</h4><ol><li>模块自定义委托加载 + 模块瘦身。</li><li>模块开启 declaredMode。</li><li>基座预置依赖。</li></ol><h2 id=declaredmode-开启方式>declaredMode 开启方式</h2><h3 id=开启条件>开启条件</h3><p>declaredMode 的本意是让模块能合并部署到基座上，所以开启前需要确保模块能本地启动成功。<br>如果是 SOFABoot 应用且涉及到模块调用基座服务的，本地启动因为没有基座服务，可以通过在模块 application.properties 添加这两个参数进行跳过（SpringBoot 应用无需关心）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 如果是 SOFABoot，则：</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 配置健康检查跳过 JVM 服务检查</span>
</span></span><span style=display:flex><span><span style=color:#c4a000>com.alipay.sofa.boot.skip-jvm-reference-health-check</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>true</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 忽略未解析的占位符</span>
</span></span><span style=display:flex><span><span style=color:#c4a000>com.alipay.sofa.ignore.unresolvable.placeholders</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>true</span>
</span></span></code></pre></div><h3 id=开启方式>开启方式</h3><p>模块打包插件里增加如下配置：<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/149473/1668428226653-d1ad571e-a580-42fa-9ca0-ff63c199dfb1.png#clientId=u664f9b10-526b-4&amp;from=paste&amp;height=399&amp;id=uf9e74e96&amp;originHeight=798&amp;originWidth=975&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=116831&amp;status=done&amp;style=none&amp;taskId=u2287fc36-ca94-4018-94f5-5a33dcb87b2&amp;title=&amp;width=487.5" alt=image.png></p><h3 id=开启后的副作用>开启后的副作用</h3><p>如果模块委托给基座的依赖里有发布服务，那么基座和模块会同时发布两份。</p><br></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=通过社区交流群 aria-label=通过社区交流群><a target=_blank rel=noopener href=/docs/contribution-guidelines/communication-channel/ aria-label=通过社区交流群><i class="fab fa-twitter"></i></a></li></ul></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=看这里 aria-label=看这里><a target=_blank rel=noopener href=/docs/contribution-guidelines/contribution/first-pr/ aria-label=看这里><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2024 Koupleless 开源社区 保留所有权利</span></div></div></div></footer></div><script src=/js/main.min.6b611378dd7aa9db092fab7032555c3f7cf1f6f0216c4527424189c537230618.js integrity="sha256-a2ETeN16qdsJL6twMlVcP3zx9vAhbEUnQkGJxTcjBhg=" crossorigin=anonymous></script>
<script src=/js/prism.js></script>
<script src=/js/tabpane-persist.js></script></body></html>